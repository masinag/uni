### PROGRAMMAZIONE DINAMICA
Basato su divide et impera, utilizzato quando lo stesso sottoproblema deve essere risolto molte volte.
In questo caso la soluzione viene memorizzata in una tabella indicizzabile in O(1) in modo da
risolvere ogni sotto-problema una volta sola.

*Problema: DOMINO
  Tessere grandi 2x1. Dato un intero n, restituire il numero di disposizioni di n tessere in un rettangolo
  2xn.
  Se non ho tessere -> 1
  Se ho 1 tessera -> 1
  Altrimenti, posso mettere l'n-esima tessera in verticale, dovendo disporre le n-1 precedenti,
  oppure in orizzontale, dovendo mettere la n-1-esima in orizzontale e quindi dovendo disporre le
  n-2 precedenti => DP[n] = DP[n-1] + DP[n-1] se n > 1
                            1 altrimenti
  => Fibonacci!
  * Scritto così ha complessità esponenziale [ Teorema delle ricorrenze lineari di ordine costante,
    a = 2 => Θ(2^n)] perchè molti sotto-problemi sono ripetuti!
  * Soluzione: Memorizziamo ogni risultato calcolato in una tabella DP che contiene un elemento per
               ogni sottoproblema.
               L'iterazione può essere top-down(Memoization) o bottom-up.
               Complessità Θ(n) sia in tempo che in spazio
  * Osservo che utilizzo sempre solo gli ultimi 2 risultati calcolati => posso salvare solo quelli
    utilizzando ϴ(1) spazio.
  # Nota che la serie cresce molto rapidamente (esponenzialmente) => sono richiesti ϴ(n) bit per
    memorizzare l'n-esimo numero di fibonacci => tutte le Complessità devono essere moltiplicate per
    un fattore n. ϴ(n²) tempo, Θ(n) spazio

* Problema: HATEVILLE
  Villaggio composto da n case, numerate da 1 a n lungo una singola strada. Ognuno odia i propri vicini
  da entrambi i lati (i-1, i+1). Hateville vuole organizzare una sagra e abbiamo il compito di raccogliere
  i fondi massimizzandone il valore, sapendo che i è disposto a donare D[i] ma se e solo se entrambi i
  propri vicini non donano.
  Definiamo HV(i) uno dei possibili insiemi di indici da selezionare per ottenere una donazione ottimale
  dalle prime i case. HV(n) è la soluz. al problema originale.
  HV(i) = highest(i ⊕ HV(i-2), HV(i-1)) (prendo l'i-esimo elemento oppure no)

  Dimostrazione correttezza- sottostruttura ottima
  Sia HV_p(i) il problema dato alle prime i case,
      HV_s(i) una soluzione ottimale per HV_p(i).
  Segue che:
    1. se i ∉ HV_s(i), allora HV_s(i) = HV_s(i-1)
    2. se i ∈ HV_s(i), allora HV_s(i) = HV_s(i-2) ∪ {i}
  DIMOSTRAZIONE:
    1. Supp che HV_s(i) non sia una soluzione ottima per HV_p(i-1), allora esisterebbe una
       soluzione migliore per i-1, ma che sarebbe a sua volta soluzione del problema i, migliore
       di quella ottima, ma ciò è assurdo.
    2. Sappiamo che i-1 ∉ HV_s(i), quindi togliendo i otteniamo una soluzione ottima per i-2.
        Se così non fosse, esisterebbe una soluzione migliore per i-2, che concatenata ad i
        produrrebbe una soluzione migliore di quella ottima per il problema i, assurdo.

        Nella tabella, memorizzare gli insiemi sarebbe costoso, per questo si memorizza solo la somma
        da cui sarà infine possibile risalire all'insieme di indici ottimo
  DP[i] = {
      max(D[i] + DP[i-2], DP[i-1]) se i>=2 # scelgo se prendere l'i-esimo oppure no
      D[i] se                      se i==1
      0                            se i==0
  }

  Data la tabella, possiamo risalire alla soluzione ottima partendo da DP[n] vedendo se è uguale a
  DP[n-1] (non ho preso n, vado a n-1) oppure no (ho preso n, vado a n-2). Se non voglio risalire alla
  soluzione, posso memorizzare solo gli ultimi 2 risultati calcolati riducendo la complessità spaziale.

* Problema: Zaino
  Dato un insieme di oggetti, ognuno caratterizzato da un peso w e da un profitto p, e uno zaino con un
  limite di capacità C, individuare un sottoinsieme di oggetti il cui peso sia inferiore alla capacità
  dello zaino e il cui valore sia massimale (il più alto tra tutti gli altri sottoinsiemi validi di
  oggetti).

  Definiamo DP[i][c] come il massimo profitto ottenibile dai primi i<=n oggetti con uno zaino di
  capacità c. Il problema originale è rappresentato da DP[n][C]

  DP[i][c] = max(DP[i-1][c], p[i] + DP[i-1][c-w[i]]) se i >= 1 ∧ c > 0 # non lo prendo vs lo prendo
             0                                       se i == 0 ∨ c == 0
             -∞                                      se c < 0
  Posso ricostruire la soluzione partendo da DP[n][C] e verificando da dove provengo

  # ATTENZIONE: T(n) = O (n*C) dove C è rappresentato con k bit (k = logC) => l'algoritmo è
    pseudo polinomiale T(n) = O(n*2^k)

  * Soluzione con memoization.
    Visto che la complessità è pseudo-polinomiale, conviene usare la versione ricorsiva? No perchè
    T(n) = 2T(n-1) +1 = O(2^n) [ conviene se 2^n << n*C ]
    Osserviamo però che non tutti gli elementi della matrice sono utili, la maggior parte vengono
    calcolati inutilmente => posso utilizzare la versione ricorsiva evitando di ricalcolare i sottoproblemi
    già risolti (MEMOIZATION). In realtà non ho un vantaggio perchè la tabella deve essere comunque
    inizializzata. Posso invece utilizzare una hash table ottenendo un costo pari a O(min(2^n, n*C))
